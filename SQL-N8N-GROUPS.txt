================================================================================
ATUALIZACOES N8N PARA SUPORTE A GRUPOS
================================================================================

MUDANCAS NECESSARIAS:
1. Upsert Identity - usar tipo 'telegram_group' quando is_group=true
2. Insert Message - salvar sender_telegram_id e sender_name no raw_payload
3. Tratar message_type (text, media, service)

================================================================================
NODE: Upsert Identity (Inbound/Sync) - ATUALIZADO
================================================================================

-- Para Inbound: substitua $json.body por $("Webhook Inbound").item.json.body
-- Para Sync: use $json.body direto

INSERT INTO contact_identities (id, owner_id, workspace_id, type, value, metadata)
VALUES (
  COALESCE(
    (SELECT id FROM contact_identities 
     WHERE workspace_id = '{{ $json.body.workspace_id }}' 
       AND type = CASE WHEN {{ $json.body.is_group }} THEN 'telegram_group' ELSE 'telegram_user' END
       AND value = '{{ $json.body.telegram_user_id }}' 
     LIMIT 1),
    gen_random_uuid()
  ),
  '{{ $json.body.owner_id }}',
  '{{ $json.body.workspace_id }}',
  CASE WHEN {{ $json.body.is_group }} THEN 'telegram_group' ELSE 'telegram_user' END,
  '{{ $json.body.telegram_user_id }}',
  CASE 
    WHEN {{ $json.body.is_group }} THEN
      jsonb_build_object(
        'is_group', true,
        'title', '{{ $json.body.group_info.title || $json.body.sender.title || "" }}',
        'username', '{{ $json.body.group_info.username || $json.body.sender.username || "" }}',
        'avatar_url', '{{ $json.body.group_info.photo_url || $json.body.sender.photo_url || "" }}',
        'participant_count', {{ $json.body.group_info.participant_count || $json.body.sender.participant_count || 'null' }}
      )
    ELSE
      jsonb_build_object(
        'first_name', '{{ $json.body.sender.first_name || "" }}',
        'last_name', '{{ $json.body.sender.last_name || "" }}',
        'username', '{{ $json.body.sender.username || "" }}',
        'avatar_url', '{{ $json.body.sender.photo_url || "" }}'
      )
  END
)
ON CONFLICT (workspace_id, type, value) DO UPDATE SET
  metadata = COALESCE(contact_identities.metadata, '{}'::jsonb) || 
    jsonb_strip_nulls(EXCLUDED.metadata),
  updated_at = NOW()
RETURNING id, metadata;

================================================================================
NODE: Build Batch SQL (Sync) - CODIGO JAVASCRIPT ATUALIZADO
================================================================================

Cole este codigo no node "Build Batch SQL":

// Gera SQL de batch insert para mensagens (com suporte a grupos)
const messages = $('Webhook Sync').item.json.body.messages || [];
const ownerId = $('Webhook Sync').item.json.body.owner_id;
const conversationId = $('Upsert Conversation (Sync)').item.json.id;
const accountId = $('Webhook Sync').item.json.body.account_id;
const identityId = $('Upsert Identity (Sync)').item.json.id;
const isGroup = $('Webhook Sync').item.json.body.is_group || false;

if (messages.length === 0) {
  return [{ json: { sql: 'SELECT 0 as messages_inserted', messages_count: 0 } }];
}

const escape = (str) => str ? str.replace(/'/g, "''") : null;

const values = messages.map(msg => {
  const text = escape(msg.text || '');
  const rawPayload = JSON.stringify({
    media_url: msg.media_url || null,
    media_type: msg.media_type || null,
    media_name: msg.media_name || null,
    message_type: msg.message_type || 'text',
    synced: true,
    is_group: isGroup,
    sender_telegram_id: msg.sender_telegram_id || null,
    sender_name: msg.sender_name || null,
    service_event: msg.service_event || null
  }).replace(/'/g, "''");
  
  return `(
    '${msg.id}'::uuid,
    '${ownerId}'::uuid,
    '${conversationId}'::uuid,
    '${accountId}'::uuid,
    '${identityId}'::uuid,
    'telegram',
    '${msg.direction}',
    ${text ? `E'${text}'` : 'NULL'},
    '${msg.date}'::timestamptz,
    '${msg.telegram_msg_id}',
    '${rawPayload}'::jsonb
  )`;
}).join(',
');

const sql = `
WITH inserted AS (
  INSERT INTO messages (
    id, owner_id, conversation_id, integration_account_id, identity_id,
    channel, direction, text, sent_at, external_message_id, raw_payload
  )
  VALUES ${values}
  ON CONFLICT (conversation_id, external_message_id) DO NOTHING
  RETURNING id
)
SELECT COUNT(*) as messages_inserted FROM inserted;
`;

return [{ json: { sql, messages_count: messages.length } }];

================================================================================
RESUMO DAS MUDANCAS:
================================================================================

1. Identity type: 'telegram_group' para grupos, 'telegram_user' para 1:1
2. Metadata de grupo inclui: title, participant_count, is_group=true
3. Mensagens de grupo incluem no raw_payload:
   - sender_telegram_id: ID de quem enviou
   - sender_name: Nome de quem enviou
   - message_type: 'text', 'media' ou 'service'
   - service_event: dados do evento (join/leave) se aplicavel
4. is_group flag em todas as mensagens
